// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0

package queries

import (
	"context"
	"database/sql"
	"fmt"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func Prepare(ctx context.Context, db DBTX) (*Queries, error) {
	q := Queries{db: db}
	var err error
	if q.createAccessGrantStmt, err = db.PrepareContext(ctx, createAccessGrant); err != nil {
		return nil, fmt.Errorf("error preparing query CreateAccessGrant: %w", err)
	}
	if q.createAccessProofStmt, err = db.PrepareContext(ctx, createAccessProof); err != nil {
		return nil, fmt.Errorf("error preparing query CreateAccessProof: %w", err)
	}
	if q.createTermsOfServiceStmt, err = db.PrepareContext(ctx, createTermsOfService); err != nil {
		return nil, fmt.Errorf("error preparing query CreateTermsOfService: %w", err)
	}
	if q.createUserStmt, err = db.PrepareContext(ctx, createUser); err != nil {
		return nil, fmt.Errorf("error preparing query CreateUser: %w", err)
	}
	if q.createUserRolesStmt, err = db.PrepareContext(ctx, createUserRoles); err != nil {
		return nil, fmt.Errorf("error preparing query CreateUserRoles: %w", err)
	}
	if q.doesInwayExistByNameStmt, err = db.PrepareContext(ctx, doesInwayExistByName); err != nil {
		return nil, fmt.Errorf("error preparing query DoesInwayExistByName: %w", err)
	}
	if q.getAccessGrantStmt, err = db.PrepareContext(ctx, getAccessGrant); err != nil {
		return nil, fmt.Errorf("error preparing query GetAccessGrant: %w", err)
	}
	if q.getLatestAccessGrantForServiceStmt, err = db.PrepareContext(ctx, getLatestAccessGrantForService); err != nil {
		return nil, fmt.Errorf("error preparing query GetLatestAccessGrantForService: %w", err)
	}
	if q.getSettingsStmt, err = db.PrepareContext(ctx, getSettings); err != nil {
		return nil, fmt.Errorf("error preparing query GetSettings: %w", err)
	}
	if q.getUserByEmailStmt, err = db.PrepareContext(ctx, getUserByEmail); err != nil {
		return nil, fmt.Errorf("error preparing query GetUserByEmail: %w", err)
	}
	if q.listAccessGrantsForServiceStmt, err = db.PrepareContext(ctx, listAccessGrantsForService); err != nil {
		return nil, fmt.Errorf("error preparing query ListAccessGrantsForService: %w", err)
	}
	if q.listAllLatestOutgoingAccessRequestsStmt, err = db.PrepareContext(ctx, listAllLatestOutgoingAccessRequests); err != nil {
		return nil, fmt.Errorf("error preparing query ListAllLatestOutgoingAccessRequests: %w", err)
	}
	if q.listInwaysForServiceStmt, err = db.PrepareContext(ctx, listInwaysForService); err != nil {
		return nil, fmt.Errorf("error preparing query ListInwaysForService: %w", err)
	}
	if q.listPermissionsStmt, err = db.PrepareContext(ctx, listPermissions); err != nil {
		return nil, fmt.Errorf("error preparing query ListPermissions: %w", err)
	}
	if q.listPermissionsForRoleStmt, err = db.PrepareContext(ctx, listPermissionsForRole); err != nil {
		return nil, fmt.Errorf("error preparing query ListPermissionsForRole: %w", err)
	}
	if q.listRolesForUserStmt, err = db.PrepareContext(ctx, listRolesForUser); err != nil {
		return nil, fmt.Errorf("error preparing query ListRolesForUser: %w", err)
	}
	if q.listServicesStmt, err = db.PrepareContext(ctx, listServices); err != nil {
		return nil, fmt.Errorf("error preparing query ListServices: %w", err)
	}
	if q.listTermsOfServiceStmt, err = db.PrepareContext(ctx, listTermsOfService); err != nil {
		return nil, fmt.Errorf("error preparing query ListTermsOfService: %w", err)
	}
	if q.revokeAccessGrantStmt, err = db.PrepareContext(ctx, revokeAccessGrant); err != nil {
		return nil, fmt.Errorf("error preparing query RevokeAccessGrant: %w", err)
	}
	if q.updateIncomingAccessRequestStmt, err = db.PrepareContext(ctx, updateIncomingAccessRequest); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateIncomingAccessRequest: %w", err)
	}
	if q.updateSettingsStmt, err = db.PrepareContext(ctx, updateSettings); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateSettings: %w", err)
	}
	if q.upsertInwayStmt, err = db.PrepareContext(ctx, upsertInway); err != nil {
		return nil, fmt.Errorf("error preparing query UpsertInway: %w", err)
	}
	return &q, nil
}

func (q *Queries) Close() error {
	var err error
	if q.createAccessGrantStmt != nil {
		if cerr := q.createAccessGrantStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createAccessGrantStmt: %w", cerr)
		}
	}
	if q.createAccessProofStmt != nil {
		if cerr := q.createAccessProofStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createAccessProofStmt: %w", cerr)
		}
	}
	if q.createTermsOfServiceStmt != nil {
		if cerr := q.createTermsOfServiceStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createTermsOfServiceStmt: %w", cerr)
		}
	}
	if q.createUserStmt != nil {
		if cerr := q.createUserStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createUserStmt: %w", cerr)
		}
	}
	if q.createUserRolesStmt != nil {
		if cerr := q.createUserRolesStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createUserRolesStmt: %w", cerr)
		}
	}
	if q.doesInwayExistByNameStmt != nil {
		if cerr := q.doesInwayExistByNameStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing doesInwayExistByNameStmt: %w", cerr)
		}
	}
	if q.getAccessGrantStmt != nil {
		if cerr := q.getAccessGrantStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getAccessGrantStmt: %w", cerr)
		}
	}
	if q.getLatestAccessGrantForServiceStmt != nil {
		if cerr := q.getLatestAccessGrantForServiceStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getLatestAccessGrantForServiceStmt: %w", cerr)
		}
	}
	if q.getSettingsStmt != nil {
		if cerr := q.getSettingsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getSettingsStmt: %w", cerr)
		}
	}
	if q.getUserByEmailStmt != nil {
		if cerr := q.getUserByEmailStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getUserByEmailStmt: %w", cerr)
		}
	}
	if q.listAccessGrantsForServiceStmt != nil {
		if cerr := q.listAccessGrantsForServiceStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listAccessGrantsForServiceStmt: %w", cerr)
		}
	}
	if q.listAllLatestOutgoingAccessRequestsStmt != nil {
		if cerr := q.listAllLatestOutgoingAccessRequestsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listAllLatestOutgoingAccessRequestsStmt: %w", cerr)
		}
	}
	if q.listInwaysForServiceStmt != nil {
		if cerr := q.listInwaysForServiceStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listInwaysForServiceStmt: %w", cerr)
		}
	}
	if q.listPermissionsStmt != nil {
		if cerr := q.listPermissionsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listPermissionsStmt: %w", cerr)
		}
	}
	if q.listPermissionsForRoleStmt != nil {
		if cerr := q.listPermissionsForRoleStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listPermissionsForRoleStmt: %w", cerr)
		}
	}
	if q.listRolesForUserStmt != nil {
		if cerr := q.listRolesForUserStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listRolesForUserStmt: %w", cerr)
		}
	}
	if q.listServicesStmt != nil {
		if cerr := q.listServicesStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listServicesStmt: %w", cerr)
		}
	}
	if q.listTermsOfServiceStmt != nil {
		if cerr := q.listTermsOfServiceStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listTermsOfServiceStmt: %w", cerr)
		}
	}
	if q.revokeAccessGrantStmt != nil {
		if cerr := q.revokeAccessGrantStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing revokeAccessGrantStmt: %w", cerr)
		}
	}
	if q.updateIncomingAccessRequestStmt != nil {
		if cerr := q.updateIncomingAccessRequestStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateIncomingAccessRequestStmt: %w", cerr)
		}
	}
	if q.updateSettingsStmt != nil {
		if cerr := q.updateSettingsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateSettingsStmt: %w", cerr)
		}
	}
	if q.upsertInwayStmt != nil {
		if cerr := q.upsertInwayStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing upsertInwayStmt: %w", cerr)
		}
	}
	return err
}

func (q *Queries) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
}

func (q *Queries) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}

type Queries struct {
	db                                      DBTX
	tx                                      *sql.Tx
	createAccessGrantStmt                   *sql.Stmt
	createAccessProofStmt                   *sql.Stmt
	createTermsOfServiceStmt                *sql.Stmt
	createUserStmt                          *sql.Stmt
	createUserRolesStmt                     *sql.Stmt
	doesInwayExistByNameStmt                *sql.Stmt
	getAccessGrantStmt                      *sql.Stmt
	getLatestAccessGrantForServiceStmt      *sql.Stmt
	getSettingsStmt                         *sql.Stmt
	getUserByEmailStmt                      *sql.Stmt
	listAccessGrantsForServiceStmt          *sql.Stmt
	listAllLatestOutgoingAccessRequestsStmt *sql.Stmt
	listInwaysForServiceStmt                *sql.Stmt
	listPermissionsStmt                     *sql.Stmt
	listPermissionsForRoleStmt              *sql.Stmt
	listRolesForUserStmt                    *sql.Stmt
	listServicesStmt                        *sql.Stmt
	listTermsOfServiceStmt                  *sql.Stmt
	revokeAccessGrantStmt                   *sql.Stmt
	updateIncomingAccessRequestStmt         *sql.Stmt
	updateSettingsStmt                      *sql.Stmt
	upsertInwayStmt                         *sql.Stmt
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db:                                      tx,
		tx:                                      tx,
		createAccessGrantStmt:                   q.createAccessGrantStmt,
		createAccessProofStmt:                   q.createAccessProofStmt,
		createTermsOfServiceStmt:                q.createTermsOfServiceStmt,
		createUserStmt:                          q.createUserStmt,
		createUserRolesStmt:                     q.createUserRolesStmt,
		doesInwayExistByNameStmt:                q.doesInwayExistByNameStmt,
		getAccessGrantStmt:                      q.getAccessGrantStmt,
		getLatestAccessGrantForServiceStmt:      q.getLatestAccessGrantForServiceStmt,
		getSettingsStmt:                         q.getSettingsStmt,
		getUserByEmailStmt:                      q.getUserByEmailStmt,
		listAccessGrantsForServiceStmt:          q.listAccessGrantsForServiceStmt,
		listAllLatestOutgoingAccessRequestsStmt: q.listAllLatestOutgoingAccessRequestsStmt,
		listInwaysForServiceStmt:                q.listInwaysForServiceStmt,
		listPermissionsStmt:                     q.listPermissionsStmt,
		listPermissionsForRoleStmt:              q.listPermissionsForRoleStmt,
		listRolesForUserStmt:                    q.listRolesForUserStmt,
		listServicesStmt:                        q.listServicesStmt,
		listTermsOfServiceStmt:                  q.listTermsOfServiceStmt,
		revokeAccessGrantStmt:                   q.revokeAccessGrantStmt,
		updateIncomingAccessRequestStmt:         q.updateIncomingAccessRequestStmt,
		updateSettingsStmt:                      q.updateSettingsStmt,
		upsertInwayStmt:                         q.upsertInwayStmt,
	}
}
